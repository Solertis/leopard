{"version":3,"sources":["leopard.js","schedule.js","congestion.js","emitter.js","rAF.js","now.js","index.js"],"names":["run","count","i","queue","length","level","counter","callback","shift","emitter","emit","enqueue","priority","times","push","flush","_i","levels","frame","frameStart","isRunning","styleEnd","styleDuration","styleStart","expectedFrame","scriptDuration","scriptEnd","scriptStart","inc","dec","strategy","accelerate","perf","Math","floor","window","performance","now","stop","requestAnimationFrame","requestIdleCallback","deadline","timeRemaining","ratio","perFrame","console","log","limit","start","options","arguments","undefined","put","getCount","_typeof","Symbol","iterator","obj","constructor","Emitter","this","uid","handlers","prototype","on","id","action","_len","args","Array","_key","forEach","handler","apply","once","_this","find","splice","indexOf","singletonEmitter","lastTime","vendors","x","cancelAnimationFrame","element","currTime","Date","getTime","timeToCall","max","setTimeout","clearTimeout","nowOffset","timing","navigationStart","Leopard","bind","exports","module","define","amd"],"mappings":"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","file":"leopard.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar Emitter = function Emitter() {\n  this.uid = 0;\n  this.handlers = [];\n  for (var i = 0; i < 1000; i++) {\n    this.handlers.push([]);\n  }\n};\nEmitter.prototype.on = function (level, callback) {\n  this.handlers[level].push({\n    id: this.uid++,\n    action: callback\n  });\n};\nEmitter.prototype.emit = function (level) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  this.handlers[level].forEach(function (handler) {\n    if (typeof handler.action === 'function') handler.action.apply(handler, args);\n  });\n};\nEmitter.prototype.once = function (level, callback) {\n  var _this = this;\n\n  var id = this.uid;\n  this.on(level, function () {\n    callback.apply(undefined, arguments);\n    var handler = _this.handlers[level].find(function (handler) {\n      return handler.id === id;\n    });\n    _this.handlers[level].splice(_this.handlers[level].indexOf(handler), 1);\n    // delete handler\n  });\n};\nvar singletonEmitter = new Emitter()\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n;(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n  /* istanbul ignore if */\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n})();\n\n// @license http://opensource.org/licenses/MIT\n// copyright Paul Irish 2015\n\n// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n(function () {\n\n  if ('performance' in window == false) {\n    window.performance = {};\n  }\n  /* istanbul ignore next */\n  Date.now = Date.now || function () {\n    // thanks IE8\n    return new Date().getTime();\n  };\n\n  if ('now' in window.performance == false) {\n\n    var nowOffset = Date.now();\n    /* istanbul ignore next */\n    if (window.performance.timing && window.performance.timing.navigationStart) {\n      nowOffset = window.performance.timing.navigationStart;\n    }\n\n    window.performance.now = function now() {\n      return Date.now() - nowOffset;\n    };\n  }\n})();\n\nvar queue = [];\nvar counter = 0;\nvar levels = 1000;\n\nfor (var i = 0; i < levels; i++) {\n  queue.push([]);\n}function run(count) {\n  for (var i = 0; i < queue.length; i++) {\n    if (count < 1) break;\n    var level = queue[i];\n    while (level.length) {\n      if (count < 1) break;\n      counter--;\n      // the bigger of level, the less emergent to complete\n      // So we deduce more for higher level (lower priority) actions\n      count = count - i * i;\n      var callback = level.shift();\n      if (callback && typeof callback === 'function') callback();\n      if (!level.length) {\n        singletonEmitter.emit(i);\n      }\n    }\n    /* istanbul ignore if */\n    if (i === queue.length - 1 && counter === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction enqueue(priority, callback, times) {\n  if (!times) {\n    queue[priority].push(callback);\n    counter++;\n  } else {\n    while (times--) {\n      queue[priority].push(callback);\n      counter++;\n    }\n  }\n}\nfunction flush() {\n  for (var _i = 0; _i < levels; _i++) {\n    queue[_i].length = 0;\n  }counter = 0;\n}\n\nvar perFrame = 16;\n\nvar expectedFrame = perFrame;\nvar limit = 1000;\nvar count = limit;\nvar strategy = 'normal';\nvar perf = 2;\n\n// var balance = options.limit\nvar isRunning = false;\nvar accelerate = 1; // for slow start\n\nvar scriptStart;\nvar scriptEnd;\nvar styleStart;\nvar styleEnd;\n\nvar styleDuration;\nvar scriptDuration;\n\nfunction frame(frameStart) {\n  if (!isRunning) return;\n  // calculate metrix\n  styleEnd = frameStart;\n  styleDuration = styleStart ? styleEnd - styleStart : expectedFrame;\n  scriptDuration = scriptEnd - scriptStart;\n\n  var inc = true;\n  var dec = true;\n  // calculate limit\n  if (strategy === 'batch') {\n    // will try to batch up all update\n    inc = scriptDuration < expectedFrame + 1;\n    dec = scriptDuration >= expectedFrame + 1;\n  } else {\n    inc = styleDuration >= expectedFrame && styleDuration < expectedFrame + 1 && styleDuration !== 0;\n    dec = styleDuration >= expectedFrame + 1;\n  }\n  if (inc) {\n    accelerate = accelerate * perf;\n    count += accelerate;\n  } else if (dec) {\n    accelerate = 1;\n    count = Math.floor(count / 2);\n    /* istanbul ignore next */\n  } else if (styleDuration === 0) {\n      // This is a skipped frame\n    }\n  if (count < 1) count = 1;\n  scriptStart = window.performance.now();\n  if (!run(count)) // stop {\n    stop();\n  scriptEnd = window.performance.now();\n  styleStart = frameStart;\n\n  window.requestAnimationFrame(frame);\n  if (window && window.requestIdleCallback) {\n    // For browsers which support requestIdleCallback\n    /* istanbul ignore next */\n    window.requestIdleCallback(function (deadline) {\n      if (deadline.timeRemaining() > 0) {\n        var ratio = deadline.timeRemaining() / perFrame;\n        run(Math.floor(count * ratio));\n      }\n    });\n  }\n}\n\nfunction stop() {\n  console.log('stop');\n  accelerate = 1; // for slow start\n  count = limit;\n  isRunning = false;\n  flush();\n}\nfunction start() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  if (!isRunning) window.requestAnimationFrame(frame);\n  options.limit && (limit = count = options.limit);\n  options.expectedFrame && (expectedFrame = options.expectedFrame);\n  options.strategy && (strategy = options.strategy);\n  options.perf && (perf = options.perf);\n  scriptStart = null;\n  scriptEnd = null;\n  styleStart = null;\n  styleEnd = null;\n  isRunning = true;\n}\nfunction put(priority, callback, times) {\n  enqueue(priority, callback, times);\n}\nfunction getCount() {\n  return count;\n}\n\nvar Leopard = {\n  on: singletonEmitter.on.bind(singletonEmitter),\n  once: singletonEmitter.once.bind(singletonEmitter),\n  start: start,\n  stop: stop,\n  put: put,\n  get limit() {\n    return getCount();\n  }\n};\n\nif ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') module.exports = Leopard;else if (typeof define === 'function' && typeof define.amd !== 'undefined') define(function () {\n  return Leopard;\n});else window.Leopard = Leopard;","import emitter from './emitter'\n\nvar queue = []\nvar counter = 0\nvar levels = 1000\n\nfor (let i = 0; i < levels; i ++) queue.push([])\n\nexport function run(count) {\n  for (var i = 0; i < queue.length; i ++) {\n    if (count < 1) break\n    var level = queue[i]\n    while (level.length) {\n      if (count < 1) break\n      counter --\n      // the bigger of level, the less emergent to complete\n      // So we deduce more for higher level (lower priority) actions\n      count = count - i * i\n      var callback = level.shift()\n      if (callback && typeof callback === 'function') callback()\n      if (!level.length) {\n        emitter.emit(i)\n      }\n    }\n    /* istanbul ignore if */\n    if (i === queue.length - 1 && counter === 0) {\n      return false\n    }\n  }\n  return true\n}\nexport function enqueue(priority, callback, times) {\n  if (!times) {\n    queue[priority].push(callback)\n    counter ++\n  } else {\n    while (times--)  {\n      queue[priority].push(callback)\n      counter ++\n    }\n  }\n}\nexport function flush() {\n  for (let i = 0; i < levels; i ++) queue[i].length = 0\n  counter = 0\n}\n","import _ from './rAF'\nimport __ from './now'\nimport { run, enqueue, flush } from './schedule'\n\n\nconst perFrame = 16\n\nvar expectedFrame = perFrame\nvar limit = 1000\nvar count = limit\nvar strategy = 'normal'\nvar perf = 2\n\n// var balance = options.limit\nvar isRunning = false\nvar accelerate = 1 // for slow start\n\nvar scriptStart\nvar scriptEnd\nvar styleStart\nvar styleEnd\n\nvar styleDuration\nvar scriptDuration\n\nfunction frame(frameStart) {\n  if (!isRunning) return\n  // calculate metrix\n  styleEnd = frameStart\n  styleDuration = styleStart ? (styleEnd - styleStart) : expectedFrame\n  scriptDuration = scriptEnd - scriptStart\n\n  var inc = true\n  var dec = true\n  // calculate limit\n  if (strategy === 'batch') {\n    // will try to batch up all update\n    inc =\n      (scriptDuration < expectedFrame + 1)\n    dec =\n      (scriptDuration >= expectedFrame + 1)\n  } else {\n    inc =\n      (styleDuration >= expectedFrame) &&\n      (styleDuration < expectedFrame + 1) &&\n      (styleDuration !== 0)\n    dec =\n      (styleDuration >= expectedFrame + 1)\n  }\n  if (inc) {\n    accelerate = accelerate * perf\n    count += accelerate\n  } else if (dec) {\n    accelerate = 1\n    count = Math.floor(count / 2)\n    /* istanbul ignore next */\n  } else if (styleDuration === 0) {\n    // This is a skipped frame\n  }\n  if (count < 1)\n    count = 1\n  scriptStart = window.performance.now()\n  if (!run(count)) // stop {\n    stop()\n  scriptEnd = window.performance.now()\n  styleStart = frameStart\n\n  window.requestAnimationFrame(frame)\n  if (window && window.requestIdleCallback) {\n    // For browsers which support requestIdleCallback\n    /* istanbul ignore next */\n    window.requestIdleCallback(function(deadline) {\n      if (deadline.timeRemaining() > 0) {\n        var ratio = deadline.timeRemaining() / perFrame\n        run(Math.floor(count * ratio))\n      }\n    })\n  }\n}\n\nexport function stop() {\n  console.log('stop');\n  accelerate = 1 // for slow start\n  count = limit\n  isRunning = false\n  flush()\n}\nexport function start(options = {}) {\n  if (!isRunning)\n    window.requestAnimationFrame(frame)\n  options.limit && (limit = count = options.limit)\n  options.expectedFrame && (expectedFrame = options.expectedFrame)\n  options.strategy && (strategy = options.strategy)\n  options.perf && (perf = options.perf)\n  scriptStart = null\n  scriptEnd = null\n  styleStart = null\n  styleEnd = null\n  isRunning = true\n}\nexport function put(priority, callback, times) {\n  enqueue(priority, callback, times)\n}\nexport function getCount() {\n  return count\n}\n","var Emitter = function() {\n  this.uid = 0\n  this.handlers = []\n  for (let i = 0; i < 1000; i ++) this.handlers.push([])\n}\nEmitter.prototype.on = function(level, callback) {\n  this.handlers[level].push({\n    id: this.uid ++,\n    action: callback\n  })\n}\nEmitter.prototype.emit = function(level, ...args) {\n  this.handlers[level].forEach(handler => {\n    if (typeof(handler.action) === 'function')\n      handler.action(...args)\n  })\n}\nEmitter.prototype.once = function(level, callback) {\n  var id = this.uid\n  this.on(level, (...args) => {\n    callback(...args)\n    var handler = this.handlers[level].find(handler => handler.id === id)\n    this.handlers[level].splice(this.handlers[level].indexOf(handler), 1)\n    // delete handler\n  })\n}\nvar singletonEmitter = new Emitter()\nexport default singletonEmitter\n","// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n;(function() {\n  var lastTime = 0\n  var vendors = ['ms', 'moz', 'webkit', 'o']\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n                                   window[vendors[x] + 'CancelRequestAnimationFrame']\n  }\n\n  if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n          var currTime = new Date().getTime()\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime))\n          var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n              timeToCall)\n          lastTime = currTime + timeToCall\n          return id\n        }\n  /* istanbul ignore if */\n  if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n          clearTimeout(id)\n        }\n}())\n","// @license http://opensource.org/licenses/MIT\n// copyright Paul Irish 2015\n\n// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n;(function() {\n\n  if ('performance' in window == false) {\n    window.performance = {}\n  }\n  /* istanbul ignore next */\n  Date.now = (Date.now || function() {  // thanks IE8\n    return new Date().getTime()\n  })\n\n  if ('now' in window.performance == false) {\n\n    var nowOffset = Date.now()\n    /* istanbul ignore next */\n    if (window.performance.timing && window.performance.timing.navigationStart) {\n      nowOffset = window.performance.timing.navigationStart\n    }\n\n    window.performance.now = function now() {\n      return Date.now() - nowOffset\n    }\n  }\n\n})()\n","import emitter from './emitter'\n\nimport {\n  start,\n  stop,\n  put,\n  getCount\n} from './congestion'\n\n\nvar Leopard = {\n  on: emitter.on.bind(emitter),\n  once: emitter.once.bind(emitter),\n  start,\n  stop,\n  put,\n  get limit() {\n    return getCount()\n  }\n}\n\nif (typeof exports === 'object')\n    module.exports = Leopard\nelse if (typeof define === 'function' && typeof define.amd !== 'undefined')\n  define(function() { return Leopard })\nelse\n  window.Leopard = Leopard\n"],"sourceRoot":"/source/"}