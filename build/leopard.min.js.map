{"version":3,"sources":["leopard.js","schedule.js","congestion.js","now.js","emitter.js","rAF.js","index.js"],"names":["run","count","i","queue","length","level","counter","callback","shift","emitter","emit","enqueue","priority","times","push","frame","frameStart","isRunning","styleEnd","styleDuration","styleStart","expectedFrame","scriptDuration","scriptEnd","scriptStart","inc","dec","focus","accelerate","perf","limit","Math","floor","performance","now","stop","requestAnimationFrame","window","requestIdleCallback","deadline","timeRemaining","ratio","perFrame","console","log","start","options","arguments","undefined","strategy","put","l","_typeof","Symbol","iterator","obj","constructor","Date","getTime","nowOffset","timing","navigationStart","Emitter","this","uid","handlers","prototype","on","id","action","_len","args","Array","_key","forEach","handler","apply","once","_this","find","splice","indexOf","singletonEmitter","levels","lastTime","vendors","x","cancelAnimationFrame","element","currTime","timeToCall","max","setTimeout","clearTimeout","Leopard","bind","exports","module","define","amd"],"mappings":"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","file":"leopard.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n// @license http://opensource.org/licenses/MIT\n// copyright Paul Irish 2015\n\n// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n(function () {\n\n  if ('performance' in window == false) {\n    window.performance = {};\n  }\n\n  Date.now = Date.now || function () {\n    // thanks IE8\n    return new Date().getTime();\n  };\n\n  if ('now' in window.performance == false) {\n\n    var nowOffset = Date.now();\n\n    if (performance.timing && performance.timing.navigationStart) {\n      nowOffset = performance.timing.navigationStart;\n    }\n\n    window.performance.now = function now() {\n      return Date.now() - nowOffset;\n    };\n  }\n})();\n\nvar Emitter = function Emitter() {\n  this.uid = 0;\n  this.handlers = [];\n  // FIX 1000\n  for (var i = 0; i < 1000; i++) {\n    this.handlers.push([]);\n  }\n};\nEmitter.prototype.on = function (level, callback) {\n  this.handlers[level].push({\n    id: this.uid++,\n    action: callback\n  });\n};\nEmitter.prototype.emit = function (level) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  this.handlers[level].forEach(function (handler) {\n    if (typeof handler.action === 'function') handler.action.apply(handler, args);\n  });\n};\nEmitter.prototype.once = function (level, callback) {\n  var _this = this;\n\n  var id = this.uid;\n  this.on(level, function () {\n    callback.apply(undefined, arguments);\n    var handler = _this.handlers[level].find(function (handler) {\n      return handler.id === id;\n    });\n    _this.handlers[level].splice(_this.handlers[level].indexOf(handler), 1);\n    // delete handler\n  });\n};\nvar singletonEmitter = new Emitter();\n\nvar queue = [];\nvar counter = 0;\nvar levels = 1000;\n\nfor (var i = 0; i < levels; i++) {\n  queue.push([]);\n}function run(count) {\n  for (var i = 0; i < queue.length; i++) {\n    if (count < 1) break;\n    var level = queue[i];\n    while (level.length) {\n      if (count < 1) break;\n      counter--;\n      // the bigger of level, the less emergent to complete\n      // So we deduce more for higher level (lower priority) actions\n      count = count - i * i;\n      var callback = level.shift();\n      if (callback && typeof callback === 'function') callback();\n      if (!level.length) {\n        singletonEmitter.emit(i);\n      }\n    }\n    if (i === queue.length - 1 && counter === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction enqueue(priority, callback, times) {\n  if (!times) {\n    queue[priority].push(callback);\n    counter++;\n  } else {\n    while (times--) {\n      queue[priority].push(callback);\n      counter++;\n    }\n  }\n}\n\nvar perFrame = 16;\n\nvar expectedFrame = perFrame;\nvar limit = 1000;\nvar strategy = 'style';\nvar perf = 2;\n\n// var balance = options.limit\nvar isRunning = false;\nvar accelerate = 1; // for slow start\n\nvar scriptStart;\nvar scriptEnd;\nvar styleStart;\nvar styleEnd;\n\nvar styleDuration;\nvar scriptDuration;\n\nfunction frame(frameStart) {\n  if (!isRunning) return;\n\n  // calculate metrix\n  styleEnd = frameStart;\n  styleDuration = styleStart ? styleEnd - styleStart : expectedFrame;\n  scriptDuration = scriptEnd - scriptStart;\n\n  var inc = true;\n  var dec = true;\n  // console.log(scriptDuration);\n\n  // calculate limit\n  if (focus === 'style') {\n    // will try to batch up all update\n    inc = scriptDuration < expectedFrame + 1;\n    dec = scriptDuration >= expectedFrame + 1;\n  } else {\n    inc = styleDuration >= expectedFrame && styleDuration < expectedFrame + 1 && styleDuration !== 0;\n    dec = styleDuration >= expectedFrame + 1;\n  }\n\n  if (inc) {\n    accelerate = accelerate * perf;\n    limit += accelerate;\n  } else if (dec) {\n    accelerate = 1;\n    limit = Math.floor(limit / 2);\n  } else if (styleDuration === 0) {\n    // This is a skipped frame\n  }\n  if (limit < 1) limit = 1;\n  scriptStart = performance.now();\n  if (!run(limit)) // stop {\n    stop();\n  scriptEnd = performance.now();\n  styleStart = frameStart;\n\n  requestAnimationFrame(frame);\n  if (window && window.requestIdleCallback) {\n    // For browsers which support requestIdleCallback\n    requestIdleCallback(function (deadline) {\n      if (deadline.timeRemaining() > 0) {\n        var ratio = deadline.timeRemaining() / perFrame;\n        run(Math.floor(limit * ratio));\n      }\n    });\n  }\n}\n\nfunction stop() {\n  console.log('stop');\n  accelerate = 1; // for slow start\n  isRunning = false;\n}\nfunction start() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  if (!isRunning) requestAnimationFrame(frame);\n  options.limit && (limit = options.limit);\n  options.expectedFrame && (expectedFrame = options.expectedFrame);\n  options.strategy && (strategy = options.strategy);\n  options.perf && (perf = options.perf);\n  scriptStart = null;\n  scriptEnd = null;\n  styleStart = null;\n  styleEnd = null;\n  isRunning = true;\n}\nfunction put(priority, callback, times) {\n  enqueue(priority, callback, times);\n  if (!isRunning) start();\n}\nfunction l() {\n  return limit;\n}\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n})();\n\nvar Leopard = {\n  on: singletonEmitter.on.bind(singletonEmitter),\n  once: singletonEmitter.once.bind(singletonEmitter),\n  start: start,\n  stop: stop,\n  put: put,\n  get limit() {\n    return l();\n  }\n};\n\nif ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') module.exports = Leopard;else if (typeof define === 'function' && typeof define.amd !== 'undefined') define(function () {\n  return Leopard;\n});else window.Leopard = Leopard;","import emitter from './emitter'\nvar queue = []\nvar counter = 0\nvar levels = 1000\n\nfor (let i = 0; i < levels; i ++) queue.push([])\n\nexport function run(count) {\n  for (var i = 0; i < queue.length; i ++) {\n    if (count < 1) break\n    var level = queue[i]\n    while (level.length) {\n      if (count < 1) break\n      counter --\n      // the bigger of level, the less emergent to complete\n      // So we deduce more for higher level (lower priority) actions\n      count = count - i * i\n      var callback = level.shift()\n      if (callback && typeof callback === 'function') callback()\n      if (!level.length) {\n        emitter.emit(i)\n      }\n    }\n    if (i === queue.length - 1 && counter === 0) {\n      return false\n    }\n  }\n  return true\n}\nexport function enqueue(priority, callback, times) {\n  if (!times) {\n    queue[priority].push(callback)\n    counter ++\n  } else {\n    while (times--)  {\n      queue[priority].push(callback)\n      counter ++\n    }\n  }\n  \n}\n","import { run, enqueue } from './schedule'\n\nconst perFrame = 16\n\nvar expectedFrame = perFrame\nvar limit = 1000\nvar strategy = 'style'\nvar perf = 2\n\n// var balance = options.limit\nvar isRunning = false\nvar accelerate = 1 // for slow start\n\nvar scriptStart\nvar scriptEnd\nvar styleStart\nvar styleEnd\n\nvar styleDuration\nvar scriptDuration\n\nfunction frame(frameStart) {\n  if (!isRunning) return\n\n  // calculate metrix\n  styleEnd = frameStart\n  styleDuration = styleStart ? (styleEnd - styleStart) : expectedFrame\n  scriptDuration = scriptEnd - scriptStart\n\n  var inc = true\n  var dec = true\n  // console.log(scriptDuration);\n  \n  // calculate limit\n  if (focus === 'style') {\n    // will try to batch up all update\n    inc =\n      (scriptDuration < expectedFrame + 1)\n    dec =\n      (scriptDuration >= expectedFrame + 1)\n  } else {\n    inc =\n      (styleDuration >= expectedFrame) &&\n      (styleDuration < expectedFrame + 1) &&\n      (styleDuration !== 0)\n    dec =\n      (styleDuration >= expectedFrame + 1)\n  }\n\n  if (inc) {\n    accelerate = accelerate * perf\n    limit += accelerate\n  } else if (dec) {\n    accelerate = 1\n    limit = Math.floor(limit / 2)\n  } else if (styleDuration === 0) {\n    // This is a skipped frame\n  }\n  if (limit < 1)\n    limit = 1\n  scriptStart = performance.now()\n  if (!run(limit)) // stop {\n    stop()\n  scriptEnd = performance.now()\n  styleStart = frameStart\n\n  requestAnimationFrame(frame)\n  if (window && window.requestIdleCallback) {\n    // For browsers which support requestIdleCallback\n    requestIdleCallback(function(deadline) {\n      if (deadline.timeRemaining() > 0) {\n        var ratio = deadline.timeRemaining() / perFrame\n        run(Math.floor(limit * ratio))\n      }\n    })\n  }\n}\n\nexport function stop() {\n  console.log('stop');\n  accelerate = 1 // for slow start\n  isRunning = false\n}\nexport function start(options = {}) {\n  if (!isRunning)\n    requestAnimationFrame(frame)\n  options.limit && (limit = options.limit)\n  options.expectedFrame && (expectedFrame = options.expectedFrame)\n  options.strategy && (strategy = options.strategy)\n  options.perf && (perf = options.perf)\n  scriptStart = null\n  scriptEnd = null\n  styleStart = null\n  styleEnd = null\n  isRunning = true\n}\nexport function put(priority, callback, times) {\n  enqueue(priority, callback, times)\n  if (!isRunning)\n    start()\n}\nexport function l() {\n  return limit\n}\n","// @license http://opensource.org/licenses/MIT\n// copyright Paul Irish 2015\n\n// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n(function() {\n\n  if ('performance' in window == false) {\n    window.performance = {}\n  }\n\n  Date.now = (Date.now || function() {  // thanks IE8\n    return new Date().getTime()\n  })\n\n  if ('now' in window.performance == false) {\n\n    var nowOffset = Date.now()\n\n    if (performance.timing && performance.timing.navigationStart) {\n      nowOffset = performance.timing.navigationStart\n    }\n\n    window.performance.now = function now() {\n      return Date.now() - nowOffset\n    }\n  }\n\n})()\n","var Emitter = function() {\n  this.uid = 0\n  this.handlers = []\n  // FIX 1000\n  for (let i = 0; i < 1000; i ++) this.handlers.push([])\n}\nEmitter.prototype.on = function(level, callback) {\n  this.handlers[level].push({\n    id: this.uid ++,\n    action: callback\n  })\n}\nEmitter.prototype.emit = function(level, ...args) {\n  this.handlers[level].forEach(handler => {\n    if (typeof(handler.action) === 'function')\n      handler.action(...args)\n  })\n}\nEmitter.prototype.once = function(level, callback) {\n  var id = this.uid\n  this.on(level, (...args) => {\n    callback(...args)\n    var handler = this.handlers[level].find(handler => handler.id === id)\n    this.handlers[level].splice(this.handlers[level].indexOf(handler), 1)\n    // delete handler\n  })\n}\nvar singletonEmitter = new Emitter()\nexport default singletonEmitter\n","// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function() {\n  var lastTime = 0\n  var vendors = ['ms', 'moz', 'webkit', 'o']\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n                                   window[vendors[x] + 'CancelRequestAnimationFrame']\n  }\n\n  if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n          var currTime = new Date().getTime()\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime))\n          var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n              timeToCall)\n          lastTime = currTime + timeToCall\n          return id\n        }\n\n  if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n          clearTimeout(id)\n        }\n}())\n","import now from './now'\nimport {\n  start,\n  stop,\n  put,\n  l\n} from './congestion'\nimport emitter from './emitter'\nimport rAF from './rAF'\n\nvar Leopard = {\n  on: emitter.on.bind(emitter),\n  once: emitter.once.bind(emitter),\n  start,\n  stop,\n  put,\n  get limit() {\n    return l()\n  }\n}\n\nif (typeof exports === 'object')\n    module.exports = Leopard\nelse if (typeof define === 'function' && typeof define.amd !== 'undefined')\n  define(function() { return Leopard })\nelse\n  window.Leopard = Leopard\n"],"sourceRoot":"/source/"}