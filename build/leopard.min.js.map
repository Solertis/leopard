{"version":3,"sources":["leopard.js","schedule.js","congestion.js","now.js","emitter.js","rAF.js","index.js"],"names":["run","count","i","queue","length","level","counter","callback","shift","emitter","emit","enqueue","priority","times","push","frame","frameStart","isRunning","styleEnd","styleDuration","styleStart","expectedFrame","scriptDuration","scriptEnd","scriptStart","inc","dec","sum","limit","c","console","log","focus","accelerate","Math","floor","performance","now","stop","requestAnimationFrame","window","requestIdleCallback","deadline","timeRemaining","ratio","perFrame","start","options","arguments","undefined","put","_typeof","Symbol","iterator","obj","constructor","Date","getTime","nowOffset","timing","navigationStart","Emitter","this","uid","handlers","prototype","on","id","action","_len","args","Array","_key","forEach","handler","apply","once","_this","find","splice","indexOf","singletonEmitter","levels","lastTime","vendors","x","cancelAnimationFrame","element","currTime","timeToCall","max","setTimeout","clearTimeout","Leopard","bind","exports","module","define","amd"],"mappings":"AAAA,YCOA,SAAgBA,KAAIC,GAClB,IAAK,GAAIC,GAAI,EAAGA,EAAIC,MAAMC,UACZ,EAARH,GAD4BC,IAAM,CAGtC,IADA,GAAIG,GAAQF,MAAMD,GACXG,EAAMD,UACC,EAARH,IADe,CAEnBK,UAGAL,GAAgBC,EAAIA,CACpB,IAAIK,GAAWF,EAAMG,OACjBD,IAAgC,kBAAbA,IAAyBA,IAC3CF,EAAMD,QACTK,iBAAQC,KAAKR,GAGjB,GAAIA,IAAMC,MAAMC,OAAS,GAAiB,IAAZE,QAC5B,OAAO,EAGX,OAAO,EAET,QAAgBK,SAAQC,EAAUL,EAAUM,GAC1C,GAAKA,EAIH,KAAOA,KACLV,MAAMS,GAAUE,KAAKP,GACrBD,cALFH,OAAMS,GAAUE,KAAKP,GACrBD,UCVJ,QAASS,OAAMC,GACb,GAAKC,UAAL,CAGAC,SAAWF,EACXG,cAAgBC,WAAcF,SAAWE,WAAcC,cACvDC,eAAiBC,UAAYC,WAG7B,IAAIC,IAAM,EACNC,GAAM,CAEVC,MAAOC,MACPC,IACAC,QAAQC,IAAIZ,eAEE,WAAVa,OACFP,EACoBJ,cAAgB,EAAjCC,eACHI,EACGJ,gBAAkBD,cAAgB,GAClB,UAAVW,OACTP,GAAM,EACNC,GAAM,IAEND,EACGN,eAAiBE,eACDA,cAAgB,EAAhCF,eACkB,IAAlBA,cACHO,EACGP,eAAiBE,cAAgB,GAGlCI,GACFQ,WAA0B,EAAbA,WACbL,OAASK,YACAP,IACTO,WAAa,EACbL,MAAQM,KAAKC,MAAMP,MAAQ,IAIjB,EAARA,QACFA,MAAQ,GACVJ,YAAcY,YAAYC,MACrBrC,IAAI4B,QACPU,OACFf,UAAYa,YAAYC,MACxBjB,WAAaJ,EAEbuB,sBAAsBxB,OAClByB,QAAUA,OAAOC,qBAEnBA,oBAAoB,SAASC,GAC3B,GAAIA,EAASC,gBAAkB,EAAG,CAChC,GAAIC,GAAQF,EAASC,gBAAkBE,QACvC7C,KAAIkC,KAAKC,MAAMP,MAAQgB,QAM/B,QAAgBN,QACdL,WAAa,EACbhB,WAAY,EAEd,QAAgB6B,SAAoB,GAAdC,GAAcC,UAAA5C,QAAA,GAAA6C,SAAAD,UAAA,MAAAA,UAAA,EAClC,KAAI/B,UAUJ,MATA8B,GAAQnB,QAAUA,MAAQmB,EAAQnB,OAClCmB,EAAQ1B,gBAAkBA,cAAgB0B,EAAQ1B,eAClD0B,EAAQf,QAAUA,MAAQe,EAAQf,OAClCR,YAAc,KACdD,UAAY,KACZH,WAAa,KACbF,SAAW,KACXD,WAAY,EAELsB,sBAAsBxB,OAE/B,QAAgBmC,KAAItC,EAAUL,EAAUM,GACtCF,QAAQC,EAAUL,EAAUM,GACvBI,WACH6B,QFtGJ,GAAIK,SAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,OAAS,eAAkBE,KGQ1O,WAUE,GARI,eAAiBd,SAAU,IAC7BA,OAAOJ,gBAGToB,KAAKnB,IAAOmB,KAAKnB,KAAO,WACtB,OAAO,GAAImB,OAAOC,WAGhB,OAASjB,QAAOJ,aAAe,EAAO,CAExC,GAAIsB,GAAYF,KAAKnB,KAEjBD,aAAYuB,QAAUvB,YAAYuB,OAAOC,kBAC3CF,EAAYtB,YAAYuB,OAAOC,iBAGjCpB,OAAOJ,YAAYC,IAAM,WACvB,MAAOmB,MAAKnB,MAAQqB,MC7B1B,IAAIG,SAAU,WACZC,KAAKC,IAAM,EACXD,KAAKE,WAEL,KAAK,GAAI9D,GAAI,EAAO,IAAJA,EAAUA,IAAM4D,KAAKE,SAASlD,SAEhD+C,SAAQI,UAAUC,GAAK,SAAS7D,EAAOE,GACrCuD,KAAKE,SAAS3D,GAAOS,MACnBqD,GAAIL,KAAKC,MACTK,OAAQ7D,KAGZsD,QAAQI,UAAUvD,KAAO,SAASL,GAAgB,IAAA,GAAAgE,GAAArB,UAAA5C,OAANkE,EAAMC,MAAAF,EAAA,EAAAA,EAAA,EAAA,GAAAG,EAAA,EAAAH,EAAAG,EAAAA,IAANF,EAAME,EAAA,GAAAxB,UAAAwB,EAChDV,MAAKE,SAAS3D,GAAOoE,QAAQ,SAAAC,GACI,kBAApBA,GAAQN,QACjBM,EAAQN,OAARO,MAAAD,EAAkBJ,MAGxBT,QAAQI,UAAUW,KAAO,SAASvE,EAAOE,GAAU,GAAAsE,GAAAf,KAC7CK,EAAKL,KAAKC,GACdD,MAAKI,GAAG7D,EAAO,WACbE,EAAAoE,MAAA1B,OAAAD,UACA,IAAI0B,GAAUG,EAAKb,SAAS3D,GAAOyE,KAAK,SAAAJ,GAAA,MAAWA,GAAQP,KAAOA,GAClEU,GAAKb,SAAS3D,GAAO0E,OAAOF,EAAKb,SAAS3D,GAAO2E,QAAQN,GAAU,KHlBvE,KAAK,GGsBDO,kBAAmB,GAAIpB,SH1BvB1D,SACAG,QAAU,EACV4E,OAAS,IAEJhF,EAAI,EAAOgF,OAAJhF,EAAYA,IAAMC,MAAMW,QCHxC,IAAM+B,UAAW,GAEbxB,cAAgBwB,SAChBjB,MAAQ,GACRI,MAAQ,SAGRf,WAAY,EACZgB,WAAa,EAEbT,YACAD,UACAH,WACAF,SAEAC,cACAG,eAEAO,EAAI,EACJF,IAAM,GGdT,WAGC,IAAK,GAFDwD,GAAW,EACXC,GAAW,KAAM,MAAO,SAAU,KAC7BC,EAAI,EAAGA,EAAID,EAAQhF,SAAWoC,OAAOD,wBAAyB8C,EACrE7C,OAAOD,sBAAwBC,OAAO4C,EAAQC,GAAK,yBACnD7C,OAAO8C,qBAAuB9C,OAAO4C,EAAQC,GAAK,yBACnB7C,OAAO4C,EAAQC,GAAK,8BAGhD7C,QAAOD,wBACNC,OAAOD,sBAAwB,SAAShC,EAAUgF,GAChD,GAAIC,IAAW,GAAIhC,OAAOC,UACtBgC,EAAavD,KAAKwD,IAAI,EAAG,IAAMF,EAAWL,IAC1ChB,EAAK3B,OAAOmD,WAAW,WAAapF,EAASiF,EAAWC,IACxDA,EAEJ,OADAN,GAAWK,EAAWC,EACftB,IAGV3B,OAAO8C,uBACN9C,OAAO8C,qBAAuB,SAASnB,GACrCyB,aAAazB,OCnBvB,IAAI0B,UACF3B,GAAIzD,iBAAQyD,GAAG4B,KAAKrF,kBACpBmE,KAAMnE,iBAAQmE,KAAKkB,KAAKrF,kBACxBqC,MAAAA,MACAR,KAAAA,KACAY,IAAAA,IAGqB,aAAnB,mBAAO6C,SAAP,YAAA5C,QAAO4C,UACPC,OAAOD,QAAUF,QACM,kBAAXI,SAA+C,mBAAfA,QAAOC,IACrDD,OAAO,WAAa,MAAOJ,WAE3BrD,OAAOqD,QAAUA","file":"leopard.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n// @license http://opensource.org/licenses/MIT\n// copyright Paul Irish 2015\n\n// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n(function () {\n\n  if ('performance' in window == false) {\n    window.performance = {};\n  }\n\n  Date.now = Date.now || function () {\n    // thanks IE8\n    return new Date().getTime();\n  };\n\n  if ('now' in window.performance == false) {\n\n    var nowOffset = Date.now();\n\n    if (performance.timing && performance.timing.navigationStart) {\n      nowOffset = performance.timing.navigationStart;\n    }\n\n    window.performance.now = function now() {\n      return Date.now() - nowOffset;\n    };\n  }\n})();\n\nvar Emitter = function Emitter() {\n  this.uid = 0;\n  this.handlers = [];\n  // FIX 1000\n  for (var i = 0; i < 1000; i++) {\n    this.handlers.push([]);\n  }\n};\nEmitter.prototype.on = function (level, callback) {\n  this.handlers[level].push({\n    id: this.uid++,\n    action: callback\n  });\n};\nEmitter.prototype.emit = function (level) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  this.handlers[level].forEach(function (handler) {\n    if (typeof handler.action === 'function') handler.action.apply(handler, args);\n  });\n};\nEmitter.prototype.once = function (level, callback) {\n  var _this = this;\n\n  var id = this.uid;\n  this.on(level, function () {\n    callback.apply(undefined, arguments);\n    var handler = _this.handlers[level].find(function (handler) {\n      return handler.id === id;\n    });\n    _this.handlers[level].splice(_this.handlers[level].indexOf(handler), 1);\n    // delete handler\n  });\n};\nvar singletonEmitter = new Emitter();\n\nvar queue = [];\nvar counter = 0;\nvar levels = 1000;\n\nfor (var i = 0; i < levels; i++) {\n  queue.push([]);\n}function run(count) {\n  for (var i = 0; i < queue.length; i++) {\n    if (count < 1) break;\n    var level = queue[i];\n    while (level.length) {\n      if (count < 1) break;\n      counter--;\n      // the bigger of level, the less emergent to complete\n      // So we deduce more for higher level (lower priority) actions\n      count = count - i * i;\n      var callback = level.shift();\n      if (callback && typeof callback === 'function') callback();\n      if (!level.length) {\n        singletonEmitter.emit(i);\n      }\n    }\n    if (i === queue.length - 1 && counter === 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction enqueue(priority, callback, times) {\n  if (!times) {\n    queue[priority].push(callback);\n    counter++;\n  } else {\n    while (times--) {\n      queue[priority].push(callback);\n      counter++;\n    }\n  }\n}\n\nvar perFrame = 16;\n\nvar expectedFrame = perFrame;\nvar limit = 10;\nvar focus = 'smooth';\n\n// var balance = options.limit\nvar isRunning = false;\nvar accelerate = 1; // for slow start\n\nvar scriptStart;\nvar scriptEnd;\nvar styleStart;\nvar styleEnd;\n\nvar styleDuration;\nvar scriptDuration;\n\nvar c = 1;\nvar sum = 0;\nfunction frame(frameStart) {\n  if (!isRunning) return;\n\n  // calculate metrix\n  styleEnd = frameStart;\n  styleDuration = styleStart ? styleEnd - styleStart : expectedFrame;\n  scriptDuration = scriptEnd - scriptStart;\n\n  var inc = true;\n  var dec = true;\n  // console.log(scriptDuration);\n  sum += limit;\n  c++;\n  console.log(styleDuration);\n  // calculate limit\n  if (focus === 'script') {\n    inc = scriptDuration < expectedFrame + 1;\n    dec = scriptDuration >= expectedFrame + 1;\n  } else if (focus === 'style') {\n    inc = true;\n    dec = false;\n  } else {\n    inc = styleDuration >= expectedFrame && styleDuration < expectedFrame + 1 && styleDuration !== 0;\n    dec = styleDuration >= expectedFrame + 1;\n  }\n\n  if (inc) {\n    accelerate = accelerate * 2;\n    limit += accelerate;\n  } else if (dec) {\n    accelerate = 1;\n    limit = Math.floor(limit / 2);\n  } else if (styleDuration === 0) {\n    // This is a skipped frame\n  }\n  if (limit < 1) limit = 1;\n  scriptStart = performance.now();\n  if (!run(limit)) // stop {\n    stop();\n  scriptEnd = performance.now();\n  styleStart = frameStart;\n\n  requestAnimationFrame(frame);\n  if (window && window.requestIdleCallback) {\n    // For browsers which support requestIdleCallback\n    requestIdleCallback(function (deadline) {\n      if (deadline.timeRemaining() > 0) {\n        var ratio = deadline.timeRemaining() / perFrame;\n        run(Math.floor(limit * ratio));\n      }\n    });\n  }\n}\n\nfunction stop() {\n  accelerate = 1; // for slow start\n  isRunning = false;\n}\nfunction start() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  if (isRunning) return;\n  options.limit && (limit = options.limit);\n  options.expectedFrame && (expectedFrame = options.expectedFrame);\n  options.focus && (focus = options.focus);\n  scriptStart = null;\n  scriptEnd = null;\n  styleStart = null;\n  styleEnd = null;\n  isRunning = true;\n\n  return requestAnimationFrame(frame);\n}\nfunction put(priority, callback, times) {\n  enqueue(priority, callback, times);\n  if (!isRunning) start();\n}\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n})();\n\nvar Leopard = {\n  on: singletonEmitter.on.bind(singletonEmitter),\n  once: singletonEmitter.once.bind(singletonEmitter),\n  start: start,\n  stop: stop,\n  put: put\n};\n\nif ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') module.exports = Leopard;else if (typeof define === 'function' && typeof define.amd !== 'undefined') define(function () {\n  return Leopard;\n});else window.Leopard = Leopard;","import emitter from './emitter'\nvar queue = []\nvar counter = 0\nvar levels = 1000\n\nfor (let i = 0; i < levels; i ++) queue.push([])\n\nexport function run(count) {\n  for (var i = 0; i < queue.length; i ++) {\n    if (count < 1) break\n    var level = queue[i]\n    while (level.length) {\n      if (count < 1) break\n      counter --\n      // the bigger of level, the less emergent to complete\n      // So we deduce more for higher level (lower priority) actions\n      count = count - i * i\n      var callback = level.shift()\n      if (callback && typeof callback === 'function') callback()\n      if (!level.length) {\n        emitter.emit(i)\n      }\n    }\n    if (i === queue.length - 1 && counter === 0) {\n      return false\n    }\n  }\n  return true\n}\nexport function enqueue(priority, callback, times) {\n  if (!times) {\n    queue[priority].push(callback)\n    counter ++\n  } else {\n    while (times--)  {\n      queue[priority].push(callback)\n      counter ++\n    }\n  }\n  \n}\n","import { run, enqueue } from './schedule'\n\nconst perFrame = 16\n\nvar expectedFrame = perFrame\nvar limit = 10\nvar focus = 'smooth'\n\n// var balance = options.limit\nvar isRunning = false\nvar accelerate = 1 // for slow start\n\nvar scriptStart\nvar scriptEnd\nvar styleStart\nvar styleEnd\n\nvar styleDuration\nvar scriptDuration\n\nvar c = 1\nvar sum = 0\nfunction frame(frameStart) {\n  if (!isRunning) return\n\n  // calculate metrix\n  styleEnd = frameStart\n  styleDuration = styleStart ? (styleEnd - styleStart) : expectedFrame\n  scriptDuration = scriptEnd - scriptStart\n  \n\n  var inc = true\n  var dec = true\n  // console.log(scriptDuration);\n  sum += limit\n  c ++\n  console.log(styleDuration);\n  // calculate limit\n  if (focus === 'script') {\n    inc = \n      (scriptDuration < expectedFrame + 1)\n    dec = \n      (scriptDuration >= expectedFrame + 1)\n  } else if (focus === 'style') {\n    inc = true\n    dec = false\n  } else {\n    inc = \n      (styleDuration >= expectedFrame) && \n      (styleDuration < expectedFrame + 1) &&\n      (styleDuration !== 0)\n    dec = \n      (styleDuration >= expectedFrame + 1)\n  }\n    \n  if (inc) {\n    accelerate = accelerate * 2\n    limit += accelerate\n  } else if (dec) {\n    accelerate = 1\n    limit = Math.floor(limit / 2)\n  } else if (styleDuration === 0) {\n    // This is a skipped frame\n  }\n  if (limit < 1)\n    limit = 1\n  scriptStart = performance.now()\n  if (!run(limit)) // stop {\n    stop()\n  scriptEnd = performance.now()\n  styleStart = frameStart\n  \n  requestAnimationFrame(frame)\n  if (window && window.requestIdleCallback) {\n    // For browsers which support requestIdleCallback\n    requestIdleCallback(function(deadline) {\n      if (deadline.timeRemaining() > 0) {\n        var ratio = deadline.timeRemaining() / perFrame\n        run(Math.floor(limit * ratio))\n      }\n    })\n  }\n}\n\nexport function stop() {\n  accelerate = 1 // for slow start\n  isRunning = false\n}\nexport function start(options = {}) {\n  if (isRunning) return\n  options.limit && (limit = options.limit)\n  options.expectedFrame && (expectedFrame = options.expectedFrame)\n  options.focus && (focus = options.focus)\n  scriptStart = null\n  scriptEnd = null\n  styleStart = null\n  styleEnd = null\n  isRunning = true\n\n  return requestAnimationFrame(frame)\n}\nexport function put(priority, callback, times) {\n  enqueue(priority, callback, times)\n  if (!isRunning)\n    start()\n}\n","// @license http://opensource.org/licenses/MIT\n// copyright Paul Irish 2015\n\n// Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n//   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n// as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n// if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n// but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n(function() {\n\n  if ('performance' in window == false) {\n    window.performance = {}\n  }\n\n  Date.now = (Date.now || function() {  // thanks IE8\n    return new Date().getTime()\n  })\n\n  if ('now' in window.performance == false) {\n\n    var nowOffset = Date.now()\n\n    if (performance.timing && performance.timing.navigationStart) {\n      nowOffset = performance.timing.navigationStart\n    }\n\n    window.performance.now = function now() {\n      return Date.now() - nowOffset\n    }\n  }\n\n})()\n","var Emitter = function() {\n  this.uid = 0\n  this.handlers = []\n  // FIX 1000\n  for (let i = 0; i < 1000; i ++) this.handlers.push([])\n}\nEmitter.prototype.on = function(level, callback) {\n  this.handlers[level].push({\n    id: this.uid ++,\n    action: callback\n  })\n}\nEmitter.prototype.emit = function(level, ...args) {\n  this.handlers[level].forEach(handler => {\n    if (typeof(handler.action) === 'function')\n      handler.action(...args)\n  })\n}\nEmitter.prototype.once = function(level, callback) {\n  var id = this.uid\n  this.on(level, (...args) => {\n    callback(...args)\n    var handler = this.handlers[level].find(handler => handler.id === id)\n    this.handlers[level].splice(this.handlers[level].indexOf(handler), 1)\n    // delete handler\n  })\n}\nvar singletonEmitter = new Emitter()\nexport default singletonEmitter\n","// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function() {\n  var lastTime = 0\n  var vendors = ['ms', 'moz', 'webkit', 'o']\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n                                   window[vendors[x] + 'CancelRequestAnimationFrame']\n  }\n\n  if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n          var currTime = new Date().getTime()\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime))\n          var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n              timeToCall)\n          lastTime = currTime + timeToCall\n          return id\n        }\n\n  if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n          clearTimeout(id)\n        }\n}())\n","import now from './now'\nimport {\n  start,\n  stop,\n  put\n} from './congestion'\nimport emitter from './emitter'\nimport rAF from './rAF'\n\nvar Leopard = {\n  on: emitter.on.bind(emitter),\n  once: emitter.once.bind(emitter),\n  start,\n  stop,\n  put\n}\n\nif (typeof exports === 'object')\n    module.exports = Leopard\nelse if (typeof define === 'function' && typeof define.amd !== 'undefined')\n  define(function() { return Leopard })\nelse\n  window.Leopard = Leopard\n"],"sourceRoot":"/source/"}